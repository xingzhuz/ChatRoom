## 实现的思路

### 登录部分

#### 客户端


- 客户端首先获取用户输入的账号ID和密码，然后封装成`JSON`，序列化为字符串，将自己的账号ID和协议ID(LOGIN)，以及数据类型(TEXT)还有这个`JSON`字符串的长度进行编码成字符串(大端方式编码)，发送给服务器，再发送实际的`JSON`字符串内容给服务器
- 客户端接收状态信息，进行处理，成功就打开聊天主界面，并记录当前用户信息，便于后续使用
- 客户端发送提示服务器更新公告和在线列表信息给，让服务器更新在线用户列表(根据`User`数组)、更新公告的显示，具体的实现就是发送给所有的在线用户，让其对应接收显示，客户端接收相关消息处理即可


#### 服务器

- 服务器首先接收到编码之后的数据，虽然上述客户端发送的数据看似`TCP`粘包了，但是由于按照固定长度(`8B`)编码，所以首先按8字节读取发送过来的编码，取出协议Id(LOGIN)进入对应的处理动作，再接收`JSON`数据，首先进行反序列化，然后解析出`JSON`数据，进行数据的判断
- 去数据库中查询当前用户名和密码是否存在，如果不存在，则登录失败，标记为`LOGIN_FAIL`
- 如果用户在数据库中已存在，检查用户是否已经处于在线列表中，如果存在，标记为LOGIN_EXIST
- 如果不存在，标记为`LOGIN_SUCCESS`，添加用户到`User`表中，即在线用户列表，返回登录成功状态，并记录当前用户信息(账户ID、用户名、登录时间)到`User`数组中，便于后续查看在线用户信息，再将这个登录的文件描述符存储起来，利用后续利用
- 然后服务器发送客户端的登录状态，是一个`JSON`字符串，发送的方式也是先发送一个表头，后面拼接实际的数据





### 发送文本

#### 客户端


- 首先客户端获取输入的文本，编码封装一个表头，包括协议ID(SEND)、数据类型(TEXT)、账户ID、文本长度，然后再发送实际的文本内容。
- 各个客户端做相应的接收，接收并解析表头数据，读出要发送过来的文本的当前块的长度，初始化内容`content=""`，然后接收具体的文本数据，将接收到的文本数据拼接到`content`上，向服务器发送当前块接收的实际字节数，也是封装了，编码了，不再赘述
- 检查发送过来的文本块大小和实际收到的块大小是否一致，如果相等，按照对应的协议类型发送信号给聊天界面的窗口，让其做对应的处理动作，比如`NOTICE`就是发送信号给界面更新公告；如果不相等，不发送信号，也就类似于丢弃当前`content`，等到服务器重传
- 直到没有数据可读，也就是服务器发送完了所有的数据块，文本完成接收

#### 服务器



- 服务器端做对应的接收，首先解析头部数据，解析出协议ID(SEND)，进行对应的处理动作，根据数据类型(TEXT)，进入接收文本内容的处理动作。
- 这个动作是：首先封装一个信息头，是根据传来的账户ID，再根据`User`数组查询这个账号Id对应的用户名，然后封装成：`用户名(accountId)说:...`这样的形式，广播发送给所有用户，再广播发送文本。
- 发送文本内容时，首先将文本内容封装成一个数据头，包括协议ID(SEND)、数据格式(TEXT)...，等待客户端的接收确认消息，然后发送具体的文本数据。
- 在发送具体的文本数据时：进行分块发送，发送指定的大小范围之类的字节数据，然后就阻塞等待客户端发送过来的确认接收的消息，并传来接收的字节长度，检测客户端确认数据的长度是否等于已发送的数据块长度，是则退出循环，继续发送下一个数据块，如果不相等，循环发送当前数据块，直到客户端收到的长度等于已发送的长度
- 然后循环一直发送，直到所有数据块发送完毕


### 发送图片

#### 客户端

- 客户端打开文件选择对话框，设置过滤器，也就是用户选择的时候，只能选择和图片相关的文件，再将选择的路径编码成`GB2312`，解决中文路径的问题，然后同样的方式，先发送编码之后的表头：协议Id(SEND),账户Id,数据类型(IMAGE),图片的大小
- 最后再以二进制方式读取图片内容，然后发送内容，也是分块发送
- 所有在线客户端需要检测服务器发来的图片，为了将其显示在聊天界面，也就是`readyON`了，首先接收表头，然后接收具体的数据，将图片内容写入文件，保存在当前工作目录下的`image`目录中，文件命名以当前时间作为命名
- 接收完数据后，发送信号给聊天窗口，聊天窗口界面做接收，然后放在`QListWidget`中，以`icon`的形式呈现在里面，固定大小。



#### 服务器

- 服务器首先解析头部数据，解析出协议类型(SEND)，进行对应的处理动作，根据数据类型(IMAGE)，进入接收图片文件内容的处理动作
- 首先接收客户端发送过来的图片内容，图片命名以当前时间戳命名，将图片读取出来保存在服务器的`image`文件夹下，然后计算出接收的文件大小和数据头传来的文件大小比较，做相应的处理动作

- 一致: 也是先向所有用户发送消息头，类似于：`用户名(accountId)说:...`，然后就是发送刚刚接收到的图片
- 和发送文本类似的步骤，也是分块发送，发送就接收确认，保证数据完整性，不同的是发送图片首先需要以二进制方式读取`Image`目录下的刚刚接收的文件，然后发送。

- 不一致: 说明服务器在接收图片文件的时候，退出循环了，大概率是客户端断开连接，所以处理异常，将文件描述符删掉，再将用户从`User`表中删去，再通知所有在线用户更新公告和在线用户列表(具体看退出部分)



### 退出部分



#### 客户端

- 客户端：点击退出按钮或者关闭当前窗口，由于重写了当前聊天窗口关闭的方法，实现体是：首先子线程退出，然后关闭登录窗口
- 由于登录窗口也重写了关闭的方法：首先是取出存储在`User`数组中的账户Id，然后根据状态区分，进入不同的if
- 区分进入不同`if`语句是因为这个窗口的关闭有可能还没进入聊天界面就关闭窗口了，还有可能是聊天主界面关闭的时候调用的这个窗口关闭，此时需要关闭写和读两个端口，只有这个登录窗口且还没登录成功的时候只有写端
- 然后以文本的方式发送退出信号给服务器，文本形式发送是首先封装一个表头，包括协议Id(LOGOUT)、账户Id、发送的内容长度(当然这里内容为空即可)、数据类型(TEXT)，发送给服务器


#### 服务器端

- 服务器做对应的接收，按照固定的8字节取出表头数据，按照协议Id(LOGOUT)进入对应的处理动作，内容部分就不用接收了，不需要，将当前和客户端通信的文件描述符关闭，还有`epoll`做对应的删除
- 再根据账户Id，从`User`表中取出对应的用户名，并拼接一条登出消息，然后将这个用户从对应的`User`表中删除用户数据，此时再从`User`表中统计在线的用户信息，然后将封装的登出消息广播发送给所有在线用户，客户端做对应的公告接收显示，将在线列表广播发送给左右在线用户，客户端作对应的在线用户列表更新显示
- 但如果客户端还没登录成功，客户端发送的文本，表头的协议Id就是(CLOSE)了，服务器做对应的接收，然后进行处理，就只是关闭文件描述符，还有将这个文件描述符从`epoll`上删除了，所有客户端有这个区分的必要


### 注册部分

#### 客户端


- 首先登录界面监听是否有点击注册按钮的事件发生，然后打开注册界面，隐藏登录界面
- 注册界面，设置账号Id、用户名、密码的输入框的一些限制，比如密码6~16位等限制，在用户点击提交之后显示(如果这些限制没达到要求，会显示出提示框)
- 限制都通过后，将账号Id、用户名、密码等封装成`JSON`，序列化成字符串，以文本形式发送给服务器，会首先封装成一个表头信息，包括协议Id(REGISTER)、账户Id、数据类型(TEXT)、文本长度(`JSON`字符串的长度)，在将实际的`JSON`字符串拼接到这个表头后，发送给服务器
- 发送完成后，等待服务器发送反馈，首先解析发送过来的表头数据，然后接收具体的`JSON`数据内容，解析`JSON`数据，读出注册状态
- 注册成功就关闭当前窗口，显示登录窗口，注册失败就显示重新注册



#### 服务器端

- 接收客户端发送过来的表头数据，解析出协议Id，进入注册的处理动作，然后读取实际的`JSON`数据内容，解析出`JSON`对象，然后读取
- 首先检查这个账号是否已经注册，去数据库中查询当前用户名和账号Id，如果数据库中存在，状态标记为注册失败，否则标志注册成功，并将这个添加到数据库中
- 将这个注册结果也是首先封装一个表头数据，然后将结果封装成`JSON`数据，序列化为字符串，加到这个表头数据结尾，发送给客户端




## 解析


### `Online.h`

- 存储了`User`表，是账号Id和用户信息之间的映射，是当前聊天的在线用户列表，用户信息存储了账户Id、用户名、登录时间，设置这个表，是为了后续便于根据账户Id，查找对应的用户名(服务器广播发送信息的时候，就能通过客户端发来的账户Id，解析出用户名，封装对应的消息头，如`zhangsan`走进聊天室等信息)，还能根据这个`User`表知道在线用户信息，便于和客户端通信，更新在线用户列表

- 存储了账户Id到文件描述符之间的映射，这个是中间桥梁，还存储了登录界面的文件描述符(和客户端登录界面建立通信的文件描述符)，到服务器和客户端实际聊天的文件描述符映射，这个映射的转换需要通过上面那个中间桥梁，映射好后
- 作用是: 通过登录界面的文件描述符，能得到这个客户端和服务器之间实际聊天通信的文件描述符(聊天界面的通信文件描述符)，得到它是为了在客户端关闭聊天窗口（就会进入关闭登录窗口，在关登录窗口发送信息给服务器表示客户端要断开连接了），服务器就会进入客户端登出的处理，由于客户端是在登录界面发送的信息，所以当前通信的文件描述符是登录界面的，不仅要关闭当前登录界面的文件描述符，还需要关闭服务器和客户端聊天的文件描述符，所以这个映射作用就出来了


### 重传机制


> 当前项目设计的模式
> 服务器向客户端发送数据，需要有客户端的确认，有误则重传当前字段
> 客户端向服务器发送数据，直接发送即可，没有设置重传机制

 - 服务器发送数据到客户端：这个过程可能是客户端主动发起的请求（例如下载文件）。此时客户端需要确认每一块数据是否正确接收，以确保文件完整下载。服务器通过重传机制，可以大幅降低下载失败的概率，提升用户体验。
- 客户端发送数据到服务器：由于客户端知道本地文件的完整性，可以在传输完成后校验或重新发送，无需逐块确认。
- 客户端发送数据给服务器时，直接发送所有数据，而不等待服务器的确认，这是为了简化客户端的逻辑，提升传输效率。客户端通常是临时的，且目标是尽快完成任务。
- 客户端需要知道往通信的缓冲区中写入了多少数据，只要写入的数据和实际要发送的数据大小一致，理论上服务器都能完整接收，这是由于 TCP 协议的可靠性保证，数据是可靠传输的